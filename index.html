<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Engineer Text Summary Generator</title>

  <!-- ‚úÖ Correct Tailwind CDN include -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter', 'sans-serif'] },
          colors: { 'primary-blue': '#1D4ED8', 'secondary-gray': '#E5E7EB' }
        }
      }
    }
  </script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #F3F4F6; }
    .spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-top-color: #3B82F6;
      border-radius: 9999px;
      width: 20px; height: 20px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg) } 100% { transform: rotate(360deg) } }
  </style>
</head>

<body class="p-4 sm:p-8">
  <div class="max-w-4xl mx-auto bg-white shadow-2xl rounded-xl p-6 sm:p-10">
    <h1 class="text-3xl sm:text-4xl font-extrabold text-primary-blue mb-2 text-center">
      Engineer Text Summary Generator
    </h1>
    <p class="text-sm text-center text-gray-500 mb-8">
      Generates a professional, structured summary using Symptoms, Cause, and Solution.
    </p>

    <!-- Input -->
    <div class="mb-6">
      <label for="engineerInput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Input Engineer's Notes
      </label>
      <textarea id="engineerInput" rows="8"
        class="w-full p-4 border border-gray-300 rounded-lg text-center focus:ring-primary-blue focus:border-primary-blue transition duration-150"
        placeholder="Paste the full, detailed technical report here."></textarea>
      <p class="text-sm text-center text-gray-500 mt-1">
        This text will be analysed and structured for you to copy and paste.
      </p>
    </div>

    <!-- Button -->
    <div class="mb-10 flex justify-center">
      <button id="generateButton" onclick="generateSummary()"
        class="flex items-center justify-center bg-primary-blue text-white font-bold py-3 px-8 rounded-xl hover:bg-blue-700 transition duration-300 shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 active:scale-95">
        <span id="buttonText">Generate Structured Summary</span>
        <div id="loadingSpinner" class="hidden spinner ml-3"></div>
      </button>
    </div>

    <!-- Output -->
    <div>
      <label for="summaryOutput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Invoice Summary
      </label>
      <textarea id="summaryOutput" rows="8" readonly
        class="w-full p-4 border border-green-500 bg-green-50 rounded-lg font-mono text-gray-800 focus:outline-none resize-none"></textarea>
      <p id="charCount" class="text-sm text-right text-gray-500 mt-1">
        Characters: 0 / 470 (Includes headers and spaces)
      </p>
      <button onclick="copyToClipboard()"
        class="mt-2 w-full bg-green-500 text-white font-semibold py-2 rounded-lg hover:bg-green-600 transition duration-300 focus:outline-none focus:ring-2 focus:ring-green-300 active:scale-95">
        Copy to Clipboard
      </button>
      <p id="copyMessage" class="text-sm text-center text-green-700 mt-2 opacity-0 transition duration-300">Copied!</p>
    </div>

    <!-- Error box -->
    <div id="messageBox" class="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg hidden" role="alert">
      <p id="errorMessage" class="font-medium"></p>
    </div>

    <p class="text-center text-gray-400 text-sm mt-8">Created by Andrew Swan</p>
  </div>

  <script>
    // üîê PASTE YOUR GOOGLE GEMINI **BROWSER API KEY** HERE (referrer-restricted)
    const USER_API_KEY = "AIzaSyCPdNJWy2xxCftu1ePgj-W3F1e48lYcLas"; // <<< REPLACE THIS

    // Model & API (GL API v1, inline prompt only)
    const MODEL_NAME = "gemini-2.5-flash";
    const API_URL    = `https://generativelanguage.googleapis.com/v1/models/${MODEL_NAME}:generateContent`;

    // Elements
    const engineerInput  = document.getElementById('engineerInput');
    const summaryOutput  = document.getElementById('summaryOutput');
    const generateButton = document.getElementById('generateButton');
    const buttonText     = document.getElementById('buttonText');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const charCount      = document.getElementById('charCount');
    const messageBox     = document.getElementById('messageBox');
    const errorMessage   = document.getElementById('errorMessage');
    const copyMessage    = document.getElementById('copyMessage');

    // Counter
    function updateCharCount() {
      const n = summaryOutput.value.length;
      charCount.textContent = `Characters: ${n} / 470 (Includes headers and spaces)`;
      if (n > 470) { charCount.classList.remove('text-gray-500'); charCount.classList.add('text-red-500'); }
      else { charCount.classList.add('text-gray-500'); charCount.classList.remove('text-red-500'); }
    }
    summaryOutput.addEventListener('input', updateCharCount);
    window.addEventListener('DOMContentLoaded', updateCharCount);

    function hideMessage() { messageBox.classList.add('hidden'); }
    function showMessage(m) { errorMessage.textContent = m; messageBox.classList.remove('hidden'); }

    // === Your exact system instruction (unchanged) ===
    const systemPrompt = `You are a professional technical summarization engine for client invoicing. Your task is to analyze detailed engineering reports (mechanical, electrical, or hydraulic) and extract the Symptoms, Cause, and Solution.

    You MUST format the output into exactly three separate paragraphs, each preceded by a bold heading and ending with a period. Use the following structure precisely, with two newline characters (\\n\\n) between each section:

    **Symptoms**
    [A professional, concise summary of the symptom(s).]

    **Cause**
    [A professional, concise summary of the cause identified.]

    **Solution**
    [A professional, concise summary of the remedy applied.]

    The total generated text, including the bold headers, paragraphs, and all newlines/spaces, MUST NOT exceed 470 characters in length. This is a strict, hard limit. Prioritize extreme brevity while maintaining professionalism.`;

    // Reminder to discourage generic placeholders and encourage facts.
    function buildUserMessage(userText) {
      const reminder =
        `\n\n[Reminder]\n` +
        `Strictly follow the exact 3-paragraph format with bold headers, two newlines between sections, ` +
        `each paragraph ends with a period, and total length ‚â§ 470 characters. ` +
        `Avoid placeholders like "not specified" or "solution performed". Use available facts (DTCs, kPa values, actions).`;
      return `${systemPrompt}${reminder}\n\n[Engineer Notes]\n${userText}`;
    }

    // Helpers to repair/complete weak outputs using facts from notes
    function extractFacts(src) {
      const t = (src || "").replace(/\s+/g, " ").trim();

      // DTC codes like P008A00
      const dtcs = Array.from(new Set((t.match(/\bP[0-9A-F]{4,6}\b/gi) || []))).slice(0,3);
      // kPa
      const kpas  = (t.match(/\b(\d{2,4})\s*kpa\b/gi) || []).map(v => v.replace(/\s+/g,""));
      // Idle / Load (before repair)
      const idleBefore = (t.match(/(low\s*idle|idle)[^0-9]*(\d{2,4})\s*kpa/i) || [])[2];
      const loadBefore = (t.match(/(under\s*load|load)[^0-9]*(\d{2,4})\s*kpa/i) || [])[2];
      // Min specs (first two occurrences)
      const specMatches = [...t.matchAll(/min\s*spec[^0-9]*(\d{2,4})\s*kpa/ig)].map(m => m[1]);
      const specIdle = specMatches[0];
      const specLoad = specMatches[1];

      // After cleaning
      const afterBlock = t.split(/after\s+cleaning\s+strainers[:\s]*/i)[1] || t.split(/after\s+cleaning[:\s]*/i)[1] || "";
      const idleAfter = (afterBlock.match(/(low\s*idle|idle)[^0-9]*(\d{2,4})\s*kpa/i) || [])[2];
      const loadAfter = (afterBlock.match(/(under\s*load|load)[^0-9]*(\d{2,4})\s*kpa/i) || [])[2];

      const underLoad = /under load|tracking|worked machine/i.test(t);
      const blocked   = /blocked|clog/i.test(t) && /strainer|strainers/i.test(t);
      const pump      = /high\/?\s*low\s*pressure\s*fuel\s*pump|fuel\s*pump/i.test(t);
      const cleaned   = /cleaned|removed\s+and\s+cleaned/i.test(t);
      const bled      = /bled/i.test(t);
      const testCode  = (t.match(/\bOPR\s*[\d-]+/i) || [])[0];
      const passed    = /passed test|no issues/i.test(t);
      const runOK     = /worked.*(30|40|45)\s*min/i.test(t) || /30-45\s*min/i.test(t);

      return {
        dtcs, kpas, idleBefore, loadBefore, specIdle, specLoad,
        idleAfter, loadAfter, underLoad, blocked, pump, cleaned, bled, testCode, passed, runOK
      };
    }

    function ensurePeriod(s) {
      s = (s || "").replace(/\s+/g, " ").trim();
      if (!/[.!?]$/.test(s)) s += ".";
      return s;
    }

    function normalizeToFormat(raw, notes) {
      const LIMIT = 470;
      let text = (raw || "").replace(/\r/g, "").trim();

      // Try to pull sections from model output
      function getSection(name) {
        const block = text.match(new RegExp(`\\*\\*${name}\\*\\*\\s*\\n([\\s\\S]*?)(?:\\n\\n|$)`, "i"));
        if (block && block[1]) return block[1].trim();
        const loose = text.match(new RegExp(`\\*\\*${name}\\*\\*[\\s\\n]+([^\\n]+)`, "i"));
        return loose ? loose[1].trim() : "";
      }

      let s = getSection("Symptoms");
      let c = getSection("Cause");
      let so= getSection("Solution");

      // Determine if a section is weak/generic
      function isWeak(x) {
        if (!x) return true;
        const y = x.toLowerCase();
        return y.length < 10 ||
               /not specified|performed|n\/a|unknown|unspecified/.test(y) ||
               ( /^the machine|^issue|^fault/.test(y) && y.length < 25 );
      }

      // Inject facts if weak
      const f = extractFacts(notes);

      if (isWeak(s)) {
        let parts = [];
        parts.push("Fuel fault");
        if (f.underLoad) parts.push("under load");
        if (f.dtcs.length) parts.push(`(${f.dtcs.join(", ")})`);
        if (f.idleBefore && f.loadBefore && (f.specIdle || f.specLoad)) {
          const specStr = (f.specIdle && f.specLoad) ? `${f.specIdle}/${f.specLoad} kPa` :
                          (f.specIdle) ? `${f.specIdle} kPa` : `${f.specLoad} kPa`;
          parts.push(`Feed pressure low: ${f.idleBefore} kPa idle / ~${f.loadBefore} kPa load (spec ${specStr})`);
        } else if (f.idleBefore && f.loadBefore) {
          parts.push(`Feed pressure low: ${f.idleBefore} kPa idle / ~${f.loadBefore} kPa load`);
        }
        s = parts.join(". ").replace(/\.\s*\./g, ". ");
      }

      if (isWeak(c)) {
        if (f.blocked && f.pump) c = "Blocked strainers at the high/low pressure fuel pump restricting feed.";
        else if (f.blocked) c = "Blocked fuel strainers restricting feed.";
        else c = "Fuel feed restriction suspected.";
      }

      if (isWeak(so)) {
        let actions = [];
        if (f.cleaned) actions.push("Removed and cleaned both strainers");
        if (f.bled) actions.push("bled system");
        if (f.idleAfter && f.loadAfter) actions.push(`pressures ${f.idleAfter} kPa idle / ~${f.loadAfter} kPa load after repair`);
        if (f.testCode) actions.push(`ran ${f.testCode}`);
        if (f.passed) actions.push("passed test");
        if (f.dtcs.length) actions.push("cleared DTCs");
        if (f.runOK) actions.push("machine worked without complaints");
        so = actions.length ? actions.join("; ") : "Verified fault and retested.";
      }

      s  = ensurePeriod(s);
      c  = ensurePeriod(c);
      so = ensurePeriod(so);

      const headerS = "**Symptoms**\n";
      const headerC = "**Cause**\n";
      const headerSo= "**Solution**\n";
      const sep     = "\n\n";

      function assemble(S, C, SO) { return headerS + S + sep + headerC + C + sep + headerSo + SO; }

      // Shrink to ‚â§ 470 by trimming longest sentence first
      function shrinkToLimit(S, C, SO) {
        let A = S, B = C, D = SO;
        let out = assemble(A, B, D);
        if (out.length <= LIMIT) return out;

        function trimWords(str, minKeep = 55) {
          let core = str.replace(/[.!?]\s*$/, "");
          let parts = core.split(" ");
          while (parts.join(" ").length > minKeep && parts.length > 3) parts.pop();
          let r = parts.join(" ").trim();
          if (!/[.!?]$/.test(r)) r += ".";
          return r;
        }

        let guard = 200;
        while (out.length > LIMIT && guard-- > 0) {
          const lens = [{k:"A",v:A.length},{k:"B",v:B.length},{k:"D",v:D.length}].sort((x,y)=>y.v-x.v);
          if (lens[0].k==="A") A = trimWords(A, 60);
          else if (lens[0].k==="B") B = trimWords(B, 60);
          else D = trimWords(D, 60);
          out = assemble(A, B, D);
          if (A.length<=10 && B.length<=10 && D.length<=10) break;
        }
        if (out.length > LIMIT) out = out.slice(0, LIMIT);
        return out;
      }

      return shrinkToLimit(s, c, so);
    }

    // Build payload (no systemInstruction)
    function buildPayload(userText) {
      const combined = buildUserMessage(userText);
      return {
        contents: [{ role: "user", parts: [{ text: combined }] }],
        generationConfig: { temperature: 0.15, maxOutputTokens: 512 }
      };
    }

    // Key guard
    function ensureKey() {
      if (typeof USER_API_KEY !== "string" || USER_API_KEY.trim().length < 30) {
        showMessage("Error: API Key is missing or too short. Paste a valid browser key in USER_API_KEY.");
        return false;
      }
      return true;
    }

    // API call
    async function callGemini(payload) {
      const url = `${API_URL}?key=${USER_API_KEY}`;
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (res.status === 401) throw new Error("API Key Invalid. Check key & referrer restrictions.");
      if (!res.ok) {
        const body = await res.json().catch(() => ({ error: { message: 'Non-JSON error response.' } }));
        throw new Error(`API Request failed with status ${res.status}: ${body.error?.message || 'Unknown API error'}`);
      }
      return res.json();
    }

    // Main
    async function generateSummary() {
      hideMessage();
      const notes = engineerInput.value.trim();

      if (!ensureKey()) return;
      if (!notes || /^paste engineers text here$/i.test(notes)) {
        showMessage("Please paste the engineer's technical notes into the input box before generating the summary.");
        return;
      }

      // UI
      generateButton.disabled = true;
      buttonText.classList.add('hidden');
      loadingSpinner.classList.remove('hidden');
      summaryOutput.value = "Generating summary...";
      updateCharCount();

      try {
        const payload = buildPayload(notes);
        const result  = await callGemini(payload);
        const raw     = result?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";

        const final = normalizeToFormat(raw, notes);
        summaryOutput.value = final || "Error: Empty response from model.";
      } catch (err) {
        console.error("Summary Generation Error:", err);
        const msg = err.message.includes("API Key Invalid")
          ? err.message
          : `Failed to generate summary. Please check your network connection and API key. Details: ${err.message}`;
        showMessage(msg);
        summaryOutput.value = "Error generating summary.";
      } finally {
        generateButton.disabled = false;
        buttonText.classList.remove('hidden');
        loadingSpinner.classList.add('hidden');
        updateCharCount();
      }
    }

    // Copy
    function copyToClipboard() {
      const val = summaryOutput.value;
      if (val && val !== "Generating summary..." && val !== "Error generating summary.") {
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(val).then(() => {
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          }).catch(err => console.error('Clipboard write failed:', err));
        } else {
          try {
            summaryOutput.select();
            document.execCommand('copy');
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          } catch (e) { console.error('Could not copy text:', e); }
        }
      } else {
        showMessage("Nothing to copy or summary is still generating/in error state.");
      }
    }

    // Expose
    window.generateSummary = generateSummary;
    window.copyToClipboard = copyToClipboard;
  </script>
</body>
</html>
