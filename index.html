<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Engineer Text Summary Generator</title>

  <!-- Tailwind CSS (correct include) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter', 'sans-serif'] },
          colors: { 'primary-blue': '#1D4ED8', 'secondary-gray': '#E5E7EB' }
        }
      }
    }
  </script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #F3F4F6; }
    .spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-top-color: #3B82F6;
      border-radius: 9999px;
      width: 20px; height: 20px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg) } 100% { transform: rotate(360deg) } }
  </style>
</head>

<body class="p-4 sm:p-8">
  <div class="max-w-4xl mx-auto bg-white shadow-2xl rounded-xl p-6 sm:p-10">
    <h1 class="text-3xl sm:text-4xl font-extrabold text-primary-blue mb-2 text-center">
      Engineer Text Summary Generator
    </h1>
    <p class="text-sm text-center text-gray-500 mb-8">
      Generates a professional, structured summary using Symptoms, Cause, and Solution.
    </p>

    <!-- Input -->
    <div class="mb-6">
      <label for="engineerInput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Input Engineer's Notes
      </label>
      <textarea id="engineerInput" rows="8"
        class="w-full p-4 border border-gray-300 rounded-lg text-center focus:ring-primary-blue focus:border-primary-blue transition duration-150"
        placeholder="Paste the full, detailed technical report here."></textarea>
      <p class="text-sm text-center text-gray-500 mt-1">
        This text will be analysed and structured for you to copy and paste.
      </p>
    </div>

    <!-- Button -->
    <div class="mb-10 flex justify-center">
      <button id="generateButton" onclick="generateSummary()"
        class="flex items-center justify-center bg-primary-blue text-white font-bold py-3 px-8 rounded-xl hover:bg-blue-700 transition duration-300 shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 active:scale-95">
        <span id="buttonText">Generate Structured Summary</span>
        <div id="loadingSpinner" class="hidden spinner ml-3"></div>
      </button>
    </div>

    <!-- Output -->
    <div>
      <label for="summaryOutput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Invoice Summary
      </label>
      <textarea id="summaryOutput" rows="8" readonly
        class="w-full p-4 border border-green-500 bg-green-50 rounded-lg font-mono text-gray-800 focus:outline-none resize-none"></textarea>
      <p id="charCount" class="text-sm text-right text-gray-500 mt-1">
        Characters: 0 / 470 (Includes headers and spaces)
      </p>
      <button onclick="copyToClipboard()"
        class="mt-2 w-full bg-green-500 text-white font-semibold py-2 rounded-lg hover:bg-green-600 transition duration-300 focus:outline-none focus:ring-2 focus:ring-green-300 active:scale-95">
        Copy to Clipboard
      </button>
      <p id="copyMessage" class="text-sm text-center text-green-700 mt-2 opacity-0 transition duration-300">Copied!</p>
    </div>

    <!-- Error box -->
    <div id="messageBox" class="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg hidden" role="alert">
      <p id="errorMessage" class="font-medium"></p>
    </div>

    <p class="text-center text-gray-400 text-sm mt-8">Created by Andrew Swan</p>
  </div>

  <script>
    // üîê PASTE YOUR GOOGLE GEMINI **BROWSER API KEY** HERE (referrer-restricted)
    const USER_API_KEY = "AIzaSyCPdNJWy2xxCftu1ePgj-W3F1e48lYcLas"; // <<< REPLACE THIS

    // Model & API (GL API v1, inline prompt only)
    const MODEL_NAME = "gemini-2.5-flash";
    const API_URL    = `https://generativelanguage.googleapis.com/v1/models/${MODEL_NAME}:generateContent`;

    // Elements
    const engineerInput  = document.getElementById('engineerInput');
    const summaryOutput  = document.getElementById('summaryOutput');
    const generateButton = document.getElementById('generateButton');
    const buttonText     = document.getElementById('buttonText');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const charCount      = document.getElementById('charCount');
    const messageBox     = document.getElementById('messageBox');
    const errorMessage   = document.getElementById('errorMessage');
    const copyMessage    = document.getElementById('copyMessage');

    // UI helpers
    function updateCharCount() {
      const n = summaryOutput.value.length;
      charCount.textContent = `Characters: ${n} / 470 (Includes headers and spaces)`;
      if (n > 470) { charCount.classList.remove('text-gray-500'); charCount.classList.add('text-red-500'); }
      else { charCount.classList.add('text-gray-500'); charCount.classList.remove('text-red-500'); }
    }
    function hideMessage() { messageBox.classList.add('hidden'); }
    function showMessage(m) { errorMessage.textContent = m; messageBox.classList.remove('hidden'); }
    summaryOutput.addEventListener('input', updateCharCount);
    window.addEventListener('DOMContentLoaded', updateCharCount);

    // === Your exact system instruction (unchanged) ===
    const systemPrompt = `You are a professional technical summarization engine for client invoicing. Your task is to analyze detailed engineering reports (mechanical, electrical, or hydraulic) and extract the Symptoms, Cause, and Solution.

    You MUST format the output into exactly three separate paragraphs, each preceded by a bold heading and ending with a period. Use the following structure precisely, with two newline characters (\\n\\n) between each section:

    **Symptoms**
    [A professional, concise summary of the symptom(s).]

    **Cause**
    [A professional, concise summary of the cause identified.]

    **Solution**
    [A professional, concise summary of the remedy applied.]

    The total generated text, including the bold headers, paragraphs, and all newlines/spaces, MUST NOT exceed 470 characters in length. This is a strict, hard limit. Prioritize extreme brevity while maintaining professionalism.`;

    // We add a small reminder (outside the systemPrompt) to nudge compression.
    function buildUserMessage(userText) {
      const reminder = `\n\n[Reminder]\nStrictly follow the exact 3-paragraph format above with bold headers, two newlines between sections, each paragraph ends with a period, and total length ‚â§ 470 characters.`;
      return `${systemPrompt}${reminder}\n\n[Engineer Notes]\n${userText}`;
    }

    // Trim helpers
    function endsWithPunct(s) { return /[.!?]$/.test(s); }
    function ensurePeriod(s)  { return endsWithPunct(s) ? s : (s.trim() + "."); }

    // Parse/repair model output into the exact required format
    function normalizeToFormat(raw) {
      const LIMIT = 470;

      let text = (raw || "").replace(/\r/g, "").trim();

      // Attempt to split by required headers
      const parts = text.split(/\n\s*\n/); // paragraphs separated by blank line
      // Find indexes of the header lines and following content
      function extract(section) {
        const rxHeader = new RegExp(`^\\*\\*${section}\\*\\*\\s*$`, "im");
        const rxBlock  = new RegExp(`\\*\\*${section}\\*\\*\\s*\\n([\\s\\S]*?)(\\n\\n|$)`, "i");
        if (!rxHeader.test(text)) return "";
        const m = text.match(rxBlock);
        return m ? m[1].trim() : "";
      }

      let s = extract("Symptoms");
      let c = extract("Cause");
      let so= extract("Solution");

      // If any missing, try looser extraction (first sentence after header markers)
      function loose(section) {
        const rx = new RegExp(`\\*\\*${section}\\*\\*[\\s\\n]+([^\\n]+)`, "i");
        const m = text.match(rx);
        return m ? m[1].trim() : "";
      }
      if (!s) s  = loose("Symptoms");
      if (!c) c  = loose("Cause");
      if (!so) so= loose("Solution");

      // If still empty, seed minimal placeholders (will compress later)
      if (!s) s = "Summary unavailable.";
      if (!c) c = "Cause not specified.";
      if (!so) so= "Solution performed.";

      // Make sure each is a single line and ends with a period
      s  = ensurePeriod(s.replace(/\s+/g, " ").trim());
      c  = ensurePeriod(c.replace(/\s+/g, " ").trim());
      so = ensurePeriod(so.replace(/\s+/g, " ").trim());

      // Assemble final block
      const headerS = "**Symptoms**\n";
      const headerC = "**Cause**\n";
      const headerSo= "**Solution**\n";
      const sep     = "\n\n";

      function assemble(a, b, d) { return headerS + a + sep + headerC + b + sep + headerSo + d; }

      // If the total exceeds 470 chars, shrink sentences proportionally
      function shrinkToLimit(a, b, d) {
        let A = a, B = b, D = d;
        let final = assemble(A, B, D);
        if (final.length <= LIMIT) return final;

        // Iteratively remove the last word from the longest sentence first
        function removeLastWord(str) {
          let core = str.replace(/[.!?]\s*$/, "");
          const words = core.split(" ");
          if (words.length <= 3) return str; // stop shrinking too far
          words.pop();
          let out = words.join(" ").trim();
          if (!/[.!?]$/.test(out)) out += ".";
          return out;
        }

        let guard = 200; // prevent infinite loops
        while (final.length > LIMIT && guard-- > 0) {
          // Pick the longest of A, B, D
          const lens = [{k:"A",v:A.length},{k:"B",v:B.length},{k:"D",v:D.length}].sort((x,y)=>y.v-x.v);
          if (lens[0].k==="A") A = removeLastWord(A);
          else if (lens[0].k==="B") B = removeLastWord(B);
          else D = removeLastWord(D);
          final = assemble(A, B, D);
          // Break if nothing changes (all too short)
          if (A.length <= 12 && B.length <= 12 && D.length <= 12) break;
        }
        // Hard crop as last resort
        if (final.length > LIMIT) final = final.slice(0, LIMIT);
        return final;
      }

      return shrinkToLimit(s, c, so);
    }

    // Build payload (no systemInstruction; inline prompt only)
    function buildPayload(userText) {
      const combined = buildUserMessage(userText);
      return {
        contents: [{ role: "user", parts: [{ text: combined }] }],
        generationConfig: { temperature: 0.1, maxOutputTokens: 512 }
      };
    }

    // Key guard
    function ensureKey() {
      if (typeof USER_API_KEY !== "string" || USER_API_KEY.trim().length < 30) {
        showMessage("Error: API Key is missing or too short. Paste a valid browser key in USER_API_KEY.");
        return false;
      }
      return true;
    }

    // API call
    async function callGemini(payload) {
      const url = `${API_URL}?key=${USER_API_KEY}`;
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (res.status === 401) throw new Error("API Key Invalid. Check key & referrer restrictions.");
      if (!res.ok) {
        const body = await res.json().catch(() => ({ error: { message: 'Non-JSON error response.' } }));
        throw new Error(`API Request failed with status ${res.status}: ${body.error?.message || 'Unknown API error'}`);
      }
      return res.json();
    }

    // Main
    async function generateSummary() {
      hideMessage();
      const notes = engineerInput.value.trim();

      if (!ensureKey()) return;
      if (!notes || /^paste engineers text here$/i.test(notes)) {
        showMessage("Please paste the engineer's technical notes into the input box before generating the summary.");
        return;
      }

      // UI
      generateButton.disabled = true;
      buttonText.classList.add('hidden');
      loadingSpinner.classList.remove('hidden');
      summaryOutput.value = "Generating summary...";
      updateCharCount();

      try {
        // Single call, no JSON to parse
        const payload = buildPayload(notes);
        const result  = await callGemini(payload);

        const text = result?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
        const final = normalizeToFormat(text);
        summaryOutput.value = final || "Error: Empty response from model.";
      } catch (err) {
        console.error("Summary Generation Error:", err);
        const msg = err.message.includes("API Key Invalid")
          ? err.message
          : `Failed to generate summary. Please check your network connection and API key. Details: ${err.message}`;
        showMessage(msg);
        summaryOutput.value = "Error generating summary.";
      } finally {
        generateButton.disabled = false;
        buttonText.classList.remove('hidden');
        loadingSpinner.classList.add('hidden');
        updateCharCount();
      }
    }

    // Copy
    function copyToClipboard() {
      const val = summaryOutput.value;
      if (val && val !== "Generating summary..." && val !== "Error generating summary.") {
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(val).then(() => {
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          }).catch(err => console.error('Clipboard write failed:', err));
        } else {
          try {
            summaryOutput.select();
            document.execCommand('copy');
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          } catch (e) { console.error('Could not copy text:', e); }
        }
      } else {
        showMessage("Nothing to copy or summary is still generating/in error state.");
      }
    }

    // Expose
    window.generateSummary = generateSummary;
    window.copyToClipboard = copyToClipboard;
  </script>
</body>
</html>
