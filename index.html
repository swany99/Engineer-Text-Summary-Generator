<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Engineer Text Summary Generator</title>

  <!-- ‚úÖ Correct Tailwind CDN include -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter', 'sans-serif'] },
          colors: { 'primary-blue': '#1D4ED8', 'secondary-gray': '#E5E7EB' }
        }
      }
    }
  </script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #F3F4F6; }
    .spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-top-color: #3B82F6;
      border-radius: 9999px;
      width: 20px; height: 20px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg) } 100% { transform: rotate(360deg) } }
  </style>
</head>

<body class="p-4 sm:p-8">
  <div class="max-w-4xl mx-auto bg-white shadow-2xl rounded-xl p-6 sm:p-10">
    <h1 class="text-3xl sm:text-4xl font-extrabold text-primary-blue mb-2 text-center">
      Engineer Text Summary Generator
    </h1>
    <p class="text-sm text-center text-gray-500 mb-8">
      Generates a professional, structured summary using Symptoms, Cause, and Solution.
    </p>

    <!-- Input Section -->
    <div class="mb-6">
      <label for="engineerInput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Input Engineer's Notes
      </label>
      <textarea id="engineerInput" rows="8"
        class="w-full p-4 border border-gray-300 rounded-lg text-center focus:ring-primary-blue focus:border-primary-blue transition duration-150"
        placeholder="Paste the full, detailed technical report here."></textarea>
      <p class="text-sm text-center text-gray-500 mt-1">
        This text will be analysed and structured for you to copy and paste.
      </p>
    </div>

    <!-- Button -->
    <div class="mb-10 flex justify-center">
      <button id="generateButton" onclick="generateSummary()"
        class="flex items-center justify-center bg-primary-blue text-white font-bold py-3 px-8 rounded-xl hover:bg-blue-700 transition duration-300 shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 active:scale-95">
        <span id="buttonText">Generate Structured Summary</span>
        <div id="loadingSpinner" class="hidden spinner ml-3"></div>
      </button>
    </div>

    <!-- Output Section -->
    <div>
      <label for="summaryOutput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Invoice Summary
      </label>
      <textarea id="summaryOutput" rows="8" readonly
        class="w-full p-4 border border-green-500 bg-green-50 rounded-lg font-mono text-gray-800 focus:outline-none resize-none"></textarea>
      <p id="charCount" class="text-sm text-right text-gray-500 mt-1">
        Characters: 0 / 470 (Includes headers and spaces)
      </p>
      <button onclick="copyToClipboard()"
        class="mt-2 w-full bg-green-500 text-white font-semibold py-2 rounded-lg hover:bg-green-600 transition duration-300 focus:outline-none focus:ring-2 focus:ring-green-300 active:scale-95">
        Copy to Clipboard
      </button>
      <p id="copyMessage" class="text-sm text-center text-green-700 mt-2 opacity-0 transition duration-300">Copied!</p>
    </div>

    <!-- Error/Message Box -->
    <div id="messageBox" class="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg hidden" role="alert">
      <p id="errorMessage" class="font-medium"></p>
    </div>

    <p class="text-center text-gray-400 text-sm mt-8">Created by Andrew Swan</p>
  </div>

  <script>
    // üîê PASTE YOUR GOOGLE GEMINI **BROWSER API KEY** HERE (referrer-restricted)
    const USER_API_KEY = "AIzaSyCPdNJWy2xxCftu1ePgj-W3F1e48lYcLas"; // <<< REPLACE WITH YOUR REAL KEY

    // Model & API (GL API v1, inline prompt only)
    const MODEL_NAME = "gemini-2.5-flash";
    const API_URL    = `https://generativelanguage.googleapis.com/v1/models/${MODEL_NAME}:generateContent`;

    // Elements
    const engineerInput  = document.getElementById('engineerInput');
    const summaryOutput  = document.getElementById('summaryOutput');
    const generateButton = document.getElementById('generateButton');
    const buttonText     = document.getElementById('buttonText');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const charCount      = document.getElementById('charCount');
    const messageBox     = document.getElementById('messageBox');
    const errorMessage   = document.getElementById('errorMessage');
    const copyMessage    = document.getElementById('copyMessage');

    // UI helpers
    function updateCharCount() {
      const n = summaryOutput.value.length;
      charCount.textContent = `Characters: ${n} / 470 (Includes headers and spaces)`;
      if (n > 470) {
        charCount.classList.remove('text-gray-500'); charCount.classList.add('text-red-500');
      } else {
        charCount.classList.add('text-gray-500'); charCount.classList.remove('text-red-500');
      }
    }
    function hideMessage() { messageBox.classList.add('hidden'); }
    function showMessage(m) { errorMessage.textContent = m; messageBox.classList.remove('hidden'); }
    summaryOutput.addEventListener('input', updateCharCount);
    window.addEventListener('DOMContentLoaded', updateCharCount);

    // === Your required final output format ===
    // **Symptoms**
    // <sentence>.
    //
    // **Cause**
    // <sentence>.
    //
    // **Solution**
    // <sentence>.
    // Total ‚â§ 470 chars.

    // === Prompt: return JSON only (we format it locally) ===
    function buildJsonPrompt(userText, strict = false) {
      const base = `
You are a professional technical summarization engine for client invoicing.

Return ONLY compact JSON with three single-sentence values (no markdown, no preamble):
{"symptoms":"...","cause":"...","solution":"..."}

Constraints:
- Each value MUST be ONE sentence, ‚â§ 120 characters.
- Be ultra-concise; include only the most essential facts for billing.
- Abbreviate units (e.g., kPa). Include only the primary DTC code if vital.
- No extra keys, no trailing text, no code fences.

[Engineer Notes]
${userText}`.trim();

      if (!strict) return base;

      // Even stricter retry variant
      return `
Return ONLY minified JSON, nothing else:
{"symptoms":"...","cause":"...","solution":"..."}

Rules:
- Exactly three keys: symptoms, cause, solution.
- ONE sentence per value, ‚â§ 120 characters each.
- No markdown, no explanations, no extra whitespace.

[Engineer Notes]
${userText}`.trim();
    }

    // Build payload (no systemInstruction; inline prompt)
    function buildPayloadJSON(userText, strict = false) {
      const combined = buildJsonPrompt(userText, strict);
      return {
        contents: [{ role: "user", parts: [{ text: combined }] }],
        generationConfig: {
          temperature: 0.05,  // keep it deterministic & terse
          maxOutputTokens: 256
        }
      };
    }

    // Parse JSON from model text (handles code fences/extraneous text)
    function safeParseJsonFromText(text) {
      if (!text) return null;
      const t = text.trim();

      // Case 1: vanilla JSON
      try { return JSON.parse(t); } catch {}

      // Case 2: fenced ```json ... ``` or ``` ... ```
      const fence = t
        .replace(/^```(?:json)?/i, "")
        .replace(/```$/i, "")
        .trim();
      try { return JSON.parse(fence); } catch {}

      // Case 3: extract first JSON-looking block
      const m = t.match(/\{[\s\S]*\}/);
      if (m) {
        try { return JSON.parse(m[0]); } catch {}
      }
      return null;
    }

    // Ensure sentence ends properly and fits
    function cleanSentence(s, maxLen) {
      if (!s) return "";
      let out = s.replace(/\s+/g, " ").trim();
      if (out.length > maxLen) out = out.slice(0, maxLen).trim();
      out = out.replace(/[;,:-]\s*$/g, "").trim();
      if (!/[.!?]$/.test(out)) out += ".";
      return out;
    }

    // Build final text with bold headers and enforce ‚â§ 470 chars
    function buildFinalText(symptoms, cause, solution) {
      const headerS = "**Symptoms**\n";
      const headerC = "**Cause**\n";
      const headerSo= "**Solution**\n";
      const sep     = "\n\n";
      const LIMIT   = 470;

      let s = cleanSentence(symptoms, 140);
      let c = cleanSentence(cause,    140);
      let so= cleanSentence(solution, 140);

      function assemble() {
        return headerS + s + sep + headerC + c + sep + headerSo + so;
      }

      let final = assemble();

      if (final.length <= LIMIT) return final;

      // Proportional shrinking: trim words from the longest first
      const over = final.length - LIMIT;
      let segments = [
        { key: "s", val: s },
        { key: "c", val: c },
        { key: "so", val: so }
      ];

      function trimWords(str, charsToSave = 40) {
        // Keep at least a short sentence
        let core = str.replace(/[.!?]\s*$/,"");
        const words = core.split(" ");
        while (words.join(" ").length > charsToSave && words.length > 3) {
          words.pop();
        }
        let out = words.join(" ").trim();
        if (!/[.!?]$/.test(out)) out += ".";
        return out;
      }

      // Iteratively shrink
      let remainingOver = over;
      segments.sort((a,b)=>b.val.length - a.val.length);
      for (let i = 0; i < segments.length && remainingOver > 0; i++) {
        const before = segments[i].val.length;
        segments[i].val = trimWords(segments[i].val, 60); // keep ~60 chars each
        remainingOver -= Math.max(0, before - segments[i].val.length);
      }

      // Reassemble
      s  = segments.find(x=>x.key==="s").val;
      c  = segments.find(x=>x.key==="c").val;
      so = segments.find(x=>x.key==="so").val;

      final = assemble();

      // Absolute last resort
      if (final.length > LIMIT) final = final.slice(0, LIMIT);
      return final;
    }

    // Heuristic fallback from the raw engineer text (no guesses, just extract)
    function heuristicFromNotes(src) {
      const text = (src || "").replace(/\s+/g, " ").trim();

      // Extract DTC codes like P008A00, P016F00, etc.
      const dtcs = Array.from(new Set((text.match(/\bP[0-9A-F]{4,5}\b/gi) || []))).slice(0,3);

      // Extract kPa values
      const kpas = (text.match(/\b(\d{2,4})\s*kpa\b/gi) || []).map(v => v.replace(/\s+/g,""));
      const lowPressure = kpas.find(v => parseInt(v) < 400); // crude check

      // Quick signals
      const hasLoad = /under load|tracking|worked machine/i.test(text);
      const fuel    = /fuel|strainer|filter|pump/i.test(text);
      const fixVerb = (text.match(/\b(replaced|cleaned|fitted|verified|aligned|retightened|retorqued|tested|flushed|reset|updated)\b/gi) || [])[0];

      // Draft sentences (keep short)
      let symptoms = "Issue reported.";
      if (fuel) symptoms = "Fuel fault reported";
      if (hasLoad) symptoms += " under load";
      if (dtcs.length) symptoms += `; codes ${dtcs.join(", ")}`;
      symptoms += ".";

      let cause = "Cause under investigation.";
      if (lowPressure) cause = `Low feed pressure (e.g., ${lowPressure}) vs spec.`;
      else if (/shear|wear|blocked|clog|leak|air/i.test(text)) cause = "Suspected restriction/air ingress in fuel system.";

      let solution = "Fault verified and tested.";
      if (fixVerb) solution = `${fixVerb.charAt(0).toUpperCase() + fixVerb.slice(1)} components/filters and retested.`;
      else if (/tested|verified/i.test(text)) solution = "Verified with gauge/TT and retested.";

      return { symptoms, cause, solution };
    }

    function ensureKey() {
      if (typeof USER_API_KEY !== "string" || USER_API_KEY.trim().length < 30) {
        showMessage("Error: API Key is missing or too short. Paste a valid browser key in USER_API_KEY.");
        return false;
      }
      return true;
    }

    async function callGemini(payload) {
      const url = `${API_URL}?key=${USER_API_KEY}`;
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (res.status === 401) throw new Error("API Key Invalid. Check key & referrer restrictions.");
      if (!res.ok) {
        const body = await res.json().catch(() => ({ error: { message: 'Non-JSON error response.' } }));
        throw new Error(`API Request failed with status ${res.status}: ${body.error?.message || 'Unknown API error'}`);
      }
      return res.json();
    }

    async function generateSummary() {
      hideMessage();
      const userText = engineerInput.value.trim();

      if (!ensureKey()) return;
      if (!userText || /^paste engineers text here$/i.test(userText)) {
        showMessage("Please paste the engineer's technical notes into the input box before generating the summary.");
        return;
      }

      // UI: loading
      generateButton.disabled = true;
      buttonText.classList.add('hidden');
      loadingSpinner.classList.remove('hidden');
      summaryOutput.value = "Generating summary...";
      updateCharCount();

      try {
        // 1) Try JSON (normal)
        let payload = buildPayloadJSON(userText, /*strict*/ false);
        let result  = await callGemini(payload);
        let rawText = result?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
        let data    = safeParseJsonFromText(rawText);

        // 2) If missing/invalid, retry once (strict)
        if (!data || !data.symptoms || !data.cause || !data.solution) {
          payload = buildPayloadJSON(userText, /*strict*/ true);
          result  = await callGemini(payload);
          rawText = result?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
          data    = safeParseJsonFromText(rawText);
        }

        // 3) If still bad, use heuristic extraction from the user's text (no model)
        if (!data || !data.symptoms || !data.cause || !data.solution) {
          const h = heuristicFromNotes(userText);
          const finalH = buildFinalText(h.symptoms, h.cause, h.solution);
          summaryOutput.value = finalH;
        } else {
          // 4) We have valid JSON -> format to your exact structure
          const finalText = buildFinalText(data.symptoms, data.cause, data.solution);
          summaryOutput.value = finalText;
        }

      } catch (err) {
        console.error("Summary Generation Error:", err);
        const msg = err.message.includes("API Key Invalid")
          ? err.message
          : `Failed to generate summary. Please check your network connection and API key. Details: ${err.message}`;
        showMessage(msg);
        summaryOutput.value = "Error generating summary.";
      } finally {
        generateButton.disabled = false;
        buttonText.classList.remove('hidden');
        loadingSpinner.classList.add('hidden');
        updateCharCount();
      }
    }

    function copyToClipboard() {
      const val = summaryOutput.value;
      if (val && val !== "Generating summary..." && val !== "Error generating summary.") {
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(val).then(() => {
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          }).catch(err => console.error('Clipboard write failed:', err));
        } else {
          try {
            summaryOutput.select();
            document.execCommand('copy');
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          } catch (e) { console.error('Could not copy text:', e); }
        }
      } else {
        showMessage("Nothing to copy or summary is still generating/in error state.");
      }
    }

    // Expose for onclick
    window.generateSummary = generateSummary;
    window.copyToClipboard = copyToClipboard;
  </script>
</body>
</html>
