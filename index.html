<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Engineer Text Summary Generator</title>

  <!-- ‚úÖ Correct Tailwind CDN include -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter', 'sans-serif'] },
          colors: { 'primary-blue': '#1D4ED8', 'secondary-gray': '#E5E7EB' }
        }
      }
    }
  </script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #F3F4F6; }
    .spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-top-color: #3B82F6;
      border-radius: 9999px;
      width: 20px; height: 20px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg) } 100% { transform: rotate(360deg) } }
  </style>
</head>

<body class="p-4 sm:p-8">
  <div class="max-w-4xl mx-auto bg-white shadow-2xl rounded-xl p-6 sm:p-10">
    <h1 class="text-3xl sm:text-4xl font-extrabold text-primary-blue mb-2 text-center">
      Engineer Text Summary Generator
    </h1>
    <p class="text-sm text-center text-gray-500 mb-8">
      Generates a professional, structured summary using Symptoms, Cause, and Solution.
    </p>

    <!-- Input Section -->
    <div class="mb-6">
      <label for="engineerInput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Input Engineer's Notes
      </label>
      <textarea id="engineerInput" rows="8"
        class="w-full p-4 border border-gray-300 rounded-lg text-center focus:ring-primary-blue focus:border-primary-blue transition duration-150"
        placeholder="Paste the full, detailed technical report here."></textarea>
      <p class="text-sm text-center text-gray-500 mt-1">
        This text will be analysed and structured for you to copy and paste.
      </p>
    </div>

    <!-- Button -->
    <div class="mb-10 flex justify-center">
      <button id="generateButton" onclick="generateSummary()"
        class="flex items-center justify-center bg-primary-blue text-white font-bold py-3 px-8 rounded-xl hover:bg-blue-700 transition duration-300 shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 active:scale-95">
        <span id="buttonText">Generate Structured Summary</span>
        <div id="loadingSpinner" class="hidden spinner ml-3"></div>
      </button>
    </div>

    <!-- Output Section -->
    <div>
      <label for="summaryOutput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Invoice Summary
      </label>
      <textarea id="summaryOutput" rows="8" readonly
        class="w-full p-4 border border-green-500 bg-green-50 rounded-lg font-mono text-gray-800 focus:outline-none resize-none"></textarea>
      <p id="charCount" class="text-sm text-right text-gray-500 mt-1">
        Characters: 0 / 470 (Includes headers and spaces)
      </p>
      <button onclick="copyToClipboard()"
        class="mt-2 w-full bg-green-500 text-white font-semibold py-2 rounded-lg hover:bg-green-600 transition duration-300 focus:outline-none focus:ring-2 focus:ring-green-300 active:scale-95">
        Copy to Clipboard
      </button>
      <p id="copyMessage" class="text-sm text-center text-green-700 mt-2 opacity-0 transition duration-300">Copied!</p>
    </div>

    <!-- Error/Message Box -->
    <div id="messageBox" class="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg hidden" role="alert">
      <p id="errorMessage" class="font-medium"></p>
    </div>

    <p class="text-center text-gray-400 text-sm mt-8">Created by Andrew Swan</p>
  </div>

  <script>
    // üîê PASTE YOUR GOOGLE GEMINI **BROWSER API KEY** HERE (referrer-restricted)
    const USER_API_KEY = "AIzaSyCPdNJWy2xxCftu1ePgj-W3F1e48lYcLas"; // <<< REPLACE WITH YOUR REAL KEY

    // Model & API (GL API v1, inline prompt only)
    const MODEL_NAME = "gemini-2.5-flash";
    const API_URL    = `https://generativelanguage.googleapis.com/v1/models/${MODEL_NAME}:generateContent`;

    // Elements
    const engineerInput  = document.getElementById('engineerInput');
    const summaryOutput  = document.getElementById('summaryOutput');
    const generateButton = document.getElementById('generateButton');
    const buttonText     = document.getElementById('buttonText');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const charCount      = document.getElementById('charCount');
    const messageBox     = document.getElementById('messageBox');
    const errorMessage   = document.getElementById('errorMessage');
    const copyMessage    = document.getElementById('copyMessage');

    // UI helpers
    function updateCharCount() {
      const n = summaryOutput.value.length;
      charCount.textContent = `Characters: ${n} / 470 (Includes headers and spaces)`;
      if (n > 470) {
        charCount.classList.remove('text-gray-500'); charCount.classList.add('text-red-500');
      } else {
        charCount.classList.add('text-gray-500'); charCount.classList.remove('text-red-500');
      }
    }
    function hideMessage() { messageBox.classList.add('hidden'); }
    function showMessage(m) { errorMessage.textContent = m; messageBox.classList.remove('hidden'); }
    summaryOutput.addEventListener('input', updateCharCount);
    window.addEventListener('DOMContentLoaded', updateCharCount);

    // === Your exact final output format ===
    // **Symptoms**
    // <sentence>.
    //
    // **Cause**
    // <sentence>.
    //
    // **Solution**
    // <sentence>.
    // Total ‚â§ 470 chars.

    // ===== Function-calling instruction =====
    // Ask Gemini to ONLY call a function with the structured result.
    function buildFunctionCallPrompt(userText) {
      return `
You are a professional technical summarization engine for client invoicing.

Read the engineer notes and return three ultra-concise, single-sentence fields:
- symptoms
- cause
- solution

Constraints (must be enforced):
- One sentence per field.
- Each field ‚â§ 120 characters.
- Be extremely concise; abbreviate units (e.g., kPa); only the most essential DTC if vital.

Respond ONLY by calling the function 'summarize_invoice' with arguments:
  symptoms: string
  cause: string
  solution: string

No extra text.

[Engineer Notes]
${userText}`.trim();
    }

    // Build payload with function declaration (tools). No systemInstruction.
    function buildPayloadFunctionCall(userText) {
      const combined = buildFunctionCallPrompt(userText);
      return {
        contents: [{ role: "user", parts: [{ text: combined }] }],
        tools: [{
          function_declarations: [{
            name: "summarize_invoice",
            description: "Return ultra-brief invoice-ready summary, one sentence per field.",
            parameters: {
              type: "OBJECT",
              properties: {
                symptoms: { type: "STRING", description: "One sentence symptoms, ‚â§120 chars." },
                cause:    { type: "STRING", description: "One sentence root cause, ‚â§120 chars." },
                solution: { type: "STRING", description: "One sentence solution/remedy, ‚â§120 chars." }
              },
              required: ["symptoms", "cause", "solution"]
            }
          }]
        }],
        generationConfig: {
          temperature: 0.05,
          maxOutputTokens: 256
        }
      };
    }

    // Fallback prompt to get raw JSON (if function call is not returned)
    function buildJsonPrompt(userText) {
      return `
Return ONLY minified JSON with three single-sentence values (no markdown, no preamble):
{"symptoms":"...","cause":"...","solution":"..."}

Rules:
- One sentence per value, ‚â§ 120 characters.
- Be ultra-concise; abbreviate units; include only essential DTC if vital.

[Engineer Notes]
${userText}`.trim();
    }
    function buildPayloadJSON(userText) {
      const combined = buildJsonPrompt(userText);
      return {
        contents: [{ role: "user", parts: [{ text: combined }] }],
        generationConfig: { temperature: 0.05, maxOutputTokens: 256 }
      };
    }

    // Helpers: parse function call / JSON
    function getFunctionCall(result) {
      try {
        const parts = result?.candidates?.[0]?.content?.parts || [];
        for (const p of parts) {
          if (p.functionCall && p.functionCall.name === "summarize_invoice") {
            return p.functionCall;
          }
        }
      } catch {}
      return null;
    }
    function safeParseJsonFromText(text) {
      if (!text) return null;
      const t = text.trim();
      try { return JSON.parse(t); } catch {}
      const fence = t.replace(/^```(?:json)?/i, "").replace(/```$/i, "").trim();
      try { return JSON.parse(fence); } catch {}
      const m = t.match(/\{[\s\S]*\}/);
      if (m) { try { return JSON.parse(m[0]); } catch {} }
      return null;
    }

    // Ensure sentence ends and fits
    function cleanSentence(s, maxLen) {
      if (!s) return "";
      let out = s.replace(/\s+/g, " ").trim();
      if (out.length > maxLen) out = out.slice(0, maxLen).trim();
      out = out.replace(/[;,:-]\s*$/g, "").trim();
      if (!/[.!?]$/.test(out)) out += ".";
      return out;
    }

    // Final formatting (bold headers, 3 paragraphs, ‚â§470)
    function buildFinalText(symptoms, cause, solution) {
      const headerS = "**Symptoms**\n";
      const headerC = "**Cause**\n";
      const headerSo= "**Solution**\n";
      const sep     = "\n\n";
      const LIMIT   = 470;

      let s  = cleanSentence(symptoms, 140);
      let c  = cleanSentence(cause,    140);
      let so = cleanSentence(solution, 140);

      function assemble() {
        return headerS + s + sep + headerC + c + sep + headerSo + so;
      }

      let final = assemble();
      if (final.length <= LIMIT) return final;

      // Proportional shrink (trim words from the longest first)
      let parts = [
        { key: "s",  val: s  },
        { key: "c",  val: c  },
        { key: "so", val: so }
      ].sort((a,b)=>b.val.length - a.val.length);

      function trimWords(str, minKeep = 50) {
        let core = str.replace(/[.!?]\s*$/,"");
        let words = core.split(" ");
        while (words.join(" ").length > minKeep && words.length > 3) {
          words.pop();
        }
        let out = words.join(" ").trim();
        if (!/[.!?]$/.test(out)) out += ".";
        return out;
      }

      let over = final.length - LIMIT;
      for (let i = 0; i < parts.length && over > 0; i++) {
        const before = parts[i].val.length;
        parts[i].val = trimWords(parts[i].val, 60);
        over -= Math.max(0, before - parts[i].val.length);
      }
      s  = parts.find(p=>p.key==="s").val;
      c  = parts.find(p=>p.key==="c").val;
      so = parts.find(p=>p.key==="so").val;

      final = assemble();
      if (final.length > LIMIT) final = final.slice(0, LIMIT); // last resort
      return final;
    }

    // Heuristic fallback (extract minimal signals from user text)
    function heuristicFromNotes(src) {
      const text = (src || "").replace(/\s+/g, " ").trim();
      const dtcs = Array.from(new Set((text.match(/\bP[0-9A-F]{4,5}\b/gi) || []))).slice(0,3);
      const kpas = (text.match(/\b(\d{2,4})\s*kpa\b/gi) || []).map(v => v.replace(/\s+/g,""));
      const lowP = kpas.find(v => parseInt(v) < 400);
      const underLoad = /under load|tracking|worked machine/i.test(text);
      const fuel = /fuel|strainer|filter|pump/i.test(text);
      const fix = (text.match(/\b(replaced|cleaned|fitted|verified|tested|flushed|reset|updated|aligned|retightened|retorqued)\b/gi) || [])[0];

      let symptoms = fuel ? "Fuel fault reported" : "Issue reported";
      if (underLoad) symptoms += " under load";
      if (dtcs.length) symptoms += `; codes ${dtcs.join(", ")}`;
      symptoms += ".";

      let cause = lowP
        ? `Low feed pressure (e.g., ${lowP}) vs spec.`
        : (/blocked|clog|leak|air/i.test(text) ? "Restriction/air ingress suspected." : "Cause under investigation.");

      let solution = fix
        ? `${fix.charAt(0).toUpperCase()+fix.slice(1)} components/filters and retested.`
        : (/tested|verified/i.test(text) ? "Verified with gauge/TT and retested." : "Verified fault and tested.");

      return { symptoms, cause, solution };
    }

    // Key & API
    function ensureKey() {
      if (typeof USER_API_KEY !== "string" || USER_API_KEY.trim().length < 30) {
        showMessage("Error: API Key is missing or too short. Paste a valid browser key in USER_API_KEY.");
        return false;
      }
      return true;
    }
    async function callGemini(payload) {
      const url = `${API_URL}?key=${USER_API_KEY}`;
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (res.status === 401) throw new Error("API Key Invalid. Check the key and referrer restrictions.");
      if (!res.ok) {
        const body = await res.json().catch(() => ({ error: { message: 'Non-JSON error response.' } }));
        throw new Error(`API Request failed with status ${res.status}: ${body.error?.message || 'Unknown API error'}`);
      }
      return res.json();
    }

    // Main
    async function generateSummary() {
      hideMessage();
      const userText = engineerInput.value.trim();

      if (!ensureKey()) return;
      if (!userText || /^paste engineers text here$/i.test(userText)) {
        showMessage("Please paste the engineer's technical notes into the input box before generating the summary.");
        return;
      }

      // UI: loading
      generateButton.disabled = true;
      buttonText.classList.add('hidden');
      loadingSpinner.classList.remove('hidden');
      summaryOutput.value = "Generating summary...";
      updateCharCount();

      try {
        // 1) Prefer function calling
        let payload = buildPayloadFunctionCall(userText);
        let result  = await callGemini(payload);
        let fc      = getFunctionCall(result);

        // 2) If no functionCall, try minified JSON
        if (!fc) {
          const payloadJson = buildPayloadJSON(userText);
          const resultJson  = await callGemini(payloadJson);
          const textJson    = resultJson?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";
          const data        = safeParseJsonFromText(textJson);

          if (data && data.symptoms && data.cause && data.solution) {
            const finalText = buildFinalText(data.symptoms, data.cause, data.solution);
            summaryOutput.value = finalText;
          } else {
            // 3) Heuristic last resort from notes (never fails)
            const h = heuristicFromNotes(userText);
            summaryOutput.value = buildFinalText(h.symptoms, h.cause, h.solution);
          }
        } else {
          // Parse arguments from function call (Gemini gives object args)
          let args = fc.args;
          // Some variants might encode args as string; try to parse if needed
          if (typeof args === "string") {
            try { args = JSON.parse(args); } catch {}
          }

          if (args && args.symptoms && args.cause && args.solution) {
            const finalText = buildFinalText(args.symptoms, args.cause, args.solution);
            summaryOutput.value = finalText;
          } else {
            // If somehow incomplete, fallback to heuristic
            const h = heuristicFromNotes(userText);
            summaryOutput.value = buildFinalText(h.symptoms, h.cause, h.solution);
          }
        }

      } catch (err) {
        console.error("Summary Generation Error:", err);
        const msg = err.message.includes("API Key Invalid")
          ? err.message
          : `Failed to generate summary. Please check your network connection and API key. Details: ${err.message}`;
        showMessage(msg);
        summaryOutput.value = "Error generating summary.";
      } finally {
        generateButton.disabled = false;
        buttonText.classList.remove('hidden');
        loadingSpinner.classList.add('hidden');
        updateCharCount();
      }
    }

    function copyToClipboard() {
      const val = summaryOutput.value;
      if (val && val !== "Generating summary..." && val !== "Error generating summary.") {
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(val).then(() => {
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          }).catch(err => console.error('Clipboard write failed:', err));
        } else {
          try {
            summaryOutput.select();
            document.execCommand('copy');
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          } catch (e) { console.error('Could not copy text:', e); }
        }
      } else {
        showMessage("Nothing to copy or summary is still generating/in error state.");
      }
    }

    // Expose for onclick
    window.generateSummary = generateSummary;
    window.copyToClipboard = copyToClipboard;
  </script>
</body>
</html>
