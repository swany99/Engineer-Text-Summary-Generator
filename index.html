<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Engineer Text Summary Generator</title>

  <!-- ‚úÖ Correct Tailwind CDN include -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter', 'sans-serif'] },
          colors: { 'primary-blue': '#1D4ED8', 'secondary-gray': '#E5E7EB' }
        }
      }
    }
  </script>
  <style>
    body { font-family: 'Inter', sans-serif; background-color: #F3F4F6; }
    .spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-top-color: #3B82F6;
      border-radius: 9999px;
      width: 20px; height: 20px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { 0% { transform: rotate(0deg) } 100% { transform: rotate(360deg) } }
  </style>
</head>

<body class="p-4 sm:p-8">
  <div class="max-w-4xl mx-auto bg-white shadow-2xl rounded-xl p-6 sm:p-10">
    <h1 class="text-3xl sm:text-4xl font-extrabold text-primary-blue mb-2 text-center">
      Engineer Text Summary Generator
    </h1>
    <p class="text-sm text-center text-gray-500 mb-8">
      Generates a professional, structured summary using Symptoms, Cause, and Solution.
    </p>

    <!-- Input Section -->
    <div class="mb-6">
      <label for="engineerInput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Input Engineer's Notes
      </label>
      <textarea id="engineerInput" rows="8"
        class="w-full p-4 border border-gray-300 rounded-lg text-center focus:ring-primary-blue focus:border-primary-blue transition duration-150"
        placeholder="Paste the full, detailed technical report here."></textarea>
      <p class="text-sm text-center text-gray-500 mt-1">
        This text will be analysed and structured for you to copy and paste.
      </p>
    </div>

    <!-- Button -->
    <div class="mb-10 flex justify-center">
      <button id="generateButton" onclick="generateSummary()"
        class="flex items-center justify-center bg-primary-blue text-white font-bold py-3 px-8 rounded-xl hover:bg-blue-700 transition duration-300 shadow-lg focus:outline-none focus:ring-4 focus:ring-blue-300 active:scale-95">
        <span id="buttonText">Generate Structured Summary</span>
        <div id="loadingSpinner" class="hidden spinner ml-3"></div>
      </button>
    </div>

    <!-- Output Section -->
    <div>
      <label for="summaryOutput" class="block text-lg text-center font-medium text-gray-700 mb-2">
        Invoice Summary
      </label>
      <textarea id="summaryOutput" rows="8" readonly
        class="w-full p-4 border border-green-500 bg-green-50 rounded-lg font-mono text-gray-800 focus:outline-none resize-none"></textarea>
      <p id="charCount" class="text-sm text-right text-gray-500 mt-1">
        Characters: 0 / 470 (Includes headers and spaces)
      </p>
      <button onclick="copyToClipboard()"
        class="mt-2 w-full bg-green-500 text-white font-semibold py-2 rounded-lg hover:bg-green-600 transition duration-300 focus:outline-none focus:ring-2 focus:ring-green-300 active:scale-95">
        Copy to Clipboard
      </button>
      <p id="copyMessage" class="text-sm text-center text-green-700 mt-2 opacity-0 transition duration-300">Copied!</p>
    </div>

    <!-- Error/Message Box -->
    <div id="messageBox" class="mt-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg hidden" role="alert">
      <p id="errorMessage" class="font-medium"></p>
    </div>

    <p class="text-center text-gray-400 text-sm mt-8">Created by Andrew Swan</p>
  </div>

  <script>
    // üîê PASTE YOUR GOOGLE GEMINI **BROWSER API KEY** HERE (referrer-restricted)
    const USER_API_KEY = "AIzaSyCPdNJWy2xxCftu1ePgj-W3F1e48lYcLas"; // <<< REPLACE WITH YOUR REAL KEY

    // Model & API (GL API v1, inline prompt only)
    const MODEL_NAME = "gemini-2.5-flash";
    const API_URL    = `https://generativelanguage.googleapis.com/v1/models/${MODEL_NAME}:generateContent`;

    // Elements
    const engineerInput  = document.getElementById('engineerInput');
    const summaryOutput  = document.getElementById('summaryOutput');
    const generateButton = document.getElementById('generateButton');
    const buttonText     = document.getElementById('buttonText');
    const loadingSpinner = document.getElementById('loadingSpinner');
    const charCount      = document.getElementById('charCount');
    const messageBox     = document.getElementById('messageBox');
    const errorMessage   = document.getElementById('errorMessage');
    const copyMessage    = document.getElementById('copyMessage');

    // UI helpers
    function updateCharCount() {
      const n = summaryOutput.value.length;
      charCount.textContent = `Characters: ${n} / 470 (Includes headers and spaces)`;
      if (n > 470) {
        charCount.classList.remove('text-gray-500'); charCount.classList.add('text-red-500');
      } else {
        charCount.classList.add('text-gray-500'); charCount.classList.remove('text-red-500');
      }
    }
    function hideMessage() { messageBox.classList.add('hidden'); }
    function showMessage(m) { errorMessage.textContent = m; messageBox.classList.remove('hidden'); }

    summaryOutput.addEventListener('input', updateCharCount);
    window.addEventListener('DOMContentLoaded', updateCharCount);

    // === Your exact final output format requirement ===
    // We will format the final text as:
    // **Symptoms**
    // <sentence>.
    //
    // **Cause**
    // <sentence>.
    //
    // **Solution**
    // <sentence>.
    // and ensure total length ‚â§ 470 characters.

    // === Prompt: return ONLY JSON (we will format it) ===
    function buildJsonPrompt(userText) {
      return `
You are a professional technical summarization engine for client invoicing.

Extract three ultra-concise, single-sentence summaries from the engineer notes:
- symptoms
- cause
- solution

Hard constraints:
- Each value MUST be ONE sentence in plain text (no lists, no extra lines).
- Each value MUST be ‚â§ 120 characters.
- Use compact wording and abbreviations (e.g., kPa). Include the primary DTC code only if essential.
- Omit tool names/brands unless necessary for clarity.
- No markdown, no code fences, no preamble, no explanations.

Return ONLY this exact JSON object, nothing else:
{"symptoms":"...","cause":"...","solution":"..."}

[Engineer Notes]
${userText}`.trim();
    }

    // Build payload (no systemInstruction; inline prompt)
    function buildPayloadJSON(userText) {
      const combined = buildJsonPrompt(userText);
      return {
        contents: [{ role: "user", parts: [{ text: combined }] }],
        generationConfig: {
          temperature: 0.1,
          maxOutputTokens: 256
        }
      };
    }

    // Parse JSON from model text (handles accidental code fences)
    function safeParseJsonFromText(text) {
      try {
        const t = text.trim()
          .replace(/^```(?:json)?/i, "")
          .replace(/```$/i, "")
          .trim();
        // Try direct parse
        return JSON.parse(t);
      } catch {
        // Try to extract the first {...} block
        const m = text.match(/\{[\s\S]*\}/);
        if (m) {
          try { return JSON.parse(m[0]); } catch { /* ignore */ }
        }
      }
      return null;
    }

    // Ensure sentence ends with a period and is trimmed to a max length
    function cleanSentence(s, maxLen) {
      if (!s) return "";
      let out = s.replace(/\s+/g, " ").trim();
      if (out.length > maxLen) out = out.slice(0, maxLen).trim();
      out = out.replace(/[;,:-]\s*$/g, "").trim(); // avoid ending on odd punctuation
      if (!/[.!?]$/.test(out)) out += ".";
      return out;
    }

    // Build the final formatted block and enforce <= 470 chars by shrinking
    function buildFinalText(symptoms, cause, solution) {
      const headerSymptoms = "**Symptoms**\n";
      const headerCause    = "**Cause**\n";
      const headerSolution = "**Solution**\n";
      const sep            = "\n\n";

      let s = cleanSentence(symptoms, 140);
      let c = cleanSentence(cause,    140);
      let so= cleanSentence(solution, 140);

      function assemble() {
        return headerSymptoms + s + sep + headerCause + c + sep + headerSolution + so;
      }

      let final = assemble();
      const LIMIT = 470;

      // If too long, shrink proportionally (largest first), preserving sentences
      if (final.length > LIMIT) {
        // Compute how much we need to cut
        const over = final.length - LIMIT;

        // Rank by length
        const arr = [
          { key: "s", val: s, len: s.length },
          { key: "c", val: c, len: c.length },
          { key: "so", val: so, len: so.length },
        ].sort((a,b)=>b.len-a.len);

        // Try iterative trimming by words until we fit
        let toCut = over;
        for (let i = 0; i < arr.length && toCut > 0; i++) {
          let { key, val } = arr[i];
          let words = val.replace(/[.!?]\s*$/,"").split(" ");
          while (words.length > 3 && toCut > 0) {
            const removed = words.pop();
            toCut -= removed.length + 1; // account for space
          }
          let shortened = words.join(" ").trim();
          if (!/[.!?]$/.test(shortened)) shortened += ".";
          if (key === "s") s = shortened;
          if (key === "c") c = shortened;
          if (key === "so") so = shortened;
        }
        final = assemble();

        // If STILL too long, hard crop the longest sentence tail safely
        if (final.length > LIMIT) {
          const parts = [
            { key: "s", val: s },
            { key: "c", val: c },
            { key: "so", val: so },
          ].sort((a,b)=>b.val.length-a.val.length);

          let remain = LIMIT - (headerSymptoms.length + headerCause.length + headerSolution.length + (sep.length*2));
          // Split remaining roughly equally
          const per = Math.max(40, Math.floor(remain / 3));
          function forceMax(x) { 
            x = x.slice(0, per).replace(/[;,:-]\s*$/g,"").trim();
            if (!/[.!?]$/.test(x)) x += ".";
            return x;
          }
          s = forceMax(s); c = forceMax(c); so = forceMax(so);
          final = assemble();
          if (final.length > LIMIT) final = final.slice(0, LIMIT); // absolute last resort
        }
      }

      return final;
    }

    function ensureKey() {
      if (typeof USER_API_KEY !== "string" || USER_API_KEY.trim().length < 30) {
        showMessage("Error: API Key is missing or too short. Paste a valid browser key in USER_API_KEY.");
        return false;
      }
      return true;
    }

    async function callGemini(payload) {
      const url = `${API_URL}?key=${USER_API_KEY}`;
      const res = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (res.status === 401) throw new Error("API Key Invalid. Check the key and referrer restrictions.");
      if (!res.ok) {
        const body = await res.json().catch(() => ({ error: { message: 'Non-JSON error response.' } }));
        throw new Error(`API Request failed with status ${res.status}: ${body.error?.message || 'Unknown API error'}`);
      }
      return res.json();
    }

    async function generateSummary() {
      hideMessage();
      const userText = engineerInput.value.trim();

      if (!ensureKey()) return;
      if (!userText || /^paste engineers text here$/i.test(userText)) {
        showMessage("Please paste the engineer's technical notes into the input box before generating the summary.");
        return;
      }

      // UI: loading
      generateButton.disabled = true;
      buttonText.classList.add('hidden');
      loadingSpinner.classList.remove('hidden');
      summaryOutput.value = "Generating summary...";
      updateCharCount();

      try {
        // Step 1: Get compact JSON
        const payload = buildPayloadJSON(userText);
        const result  = await callGemini(payload);
        const text    = result?.candidates?.[0]?.content?.parts?.[0]?.text ?? "";

        const json = safeParseJsonFromText(text);
        if (!json || !json.symptoms || !json.cause || !json.solution) {
          throw new Error("Model did not return valid JSON with required keys.");
        }

        // Step 2: Format exactly as required and fit within 470 chars
        const finalText = buildFinalText(json.symptoms, json.cause, json.solution);
        summaryOutput.value = finalText;

      } catch (err) {
        console.error("Summary Generation Error:", err);
        const msg = err.message.includes("API Key Invalid")
          ? err.message
          : `Failed to generate summary. Please check your network connection and API key. Details: ${err.message}`;
        showMessage(msg);
        summaryOutput.value = "Error generating summary.";
      } finally {
        generateButton.disabled = false;
        buttonText.classList.remove('hidden');
        loadingSpinner.classList.add('hidden');
        updateCharCount();
      }
    }

    function copyToClipboard() {
      const val = summaryOutput.value;
      if (val && val !== "Generating summary..." && val !== "Error generating summary.") {
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(val).then(() => {
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          }).catch(err => console.error('Clipboard write failed:', err));
        } else {
          try {
            summaryOutput.select();
            document.execCommand('copy');
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          } catch (e) { console.error('Could not copy text:', e); }
        }
      } else {
        showMessage("Nothing to copy or summary is still generating/in error state.");
      }
    }

    // Expose for onclick
    window.generateSummary = generateSummary;
    window.copyToClipboard = copyToClipboard;
  </script>
</body>
</html>
