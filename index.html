<script>
  // üîê PASTE YOUR GOOGLE GEMINI **BROWSER API KEY** HERE (referrer-restricted)
  // Example: "AIzaSyA...<rest>..."
  const USER_API_KEY = "AIzaSyAienUmrR_kJEsHajpflPWltvGx316gFBQ"; // <<< REPLACE WITH YOUR REAL KEY

  // Model & API
  const MODEL_NAME = "gemini-2.5-flash";
  const API_URL = `https://generativelanguage.googleapis.com/v1/models/${MODEL_NAME}:generateContent`;

  // Elements
  const engineerInput  = document.getElementById('engineerInput');
  const summaryOutput  = document.getElementById('summaryOutput');
  const generateButton = document.getElementById('generateButton');
  const buttonText     = document.getElementById('buttonText');
  const loadingSpinner = document.getElementById('loadingSpinner');
  const charCount      = document.getElementById('charCount');
  const messageBox     = document.getElementById('messageBox');
  const errorMessage   = document.getElementById('errorMessage');
  const copyMessage    = document.getElementById('copyMessage');

  // Character counter
  function updateCharCount() {
    const currentLength = summaryOutput.value.length;
    charCount.textContent = `Characters: ${currentLength} / 470 (Includes headers and spaces)`;
    if (currentLength > 470) {
      charCount.classList.remove('text-gray-500');
      charCount.classList.add('text-red-500');
    } else {
      charCount.classList.add('text-gray-500');
      charCount.classList.remove('text-red-500');
    }
  }
  summaryOutput.addEventListener('input', updateCharCount);
  window.addEventListener('DOMContentLoaded', updateCharCount);

  function hideMessage() { messageBox.classList.add('hidden'); }
  function showMessage(message) { errorMessage.textContent = message; messageBox.classList.remove('hidden'); }

  // --- Your EXACT system instruction (unchanged) ---
  const systemPrompt = `You are a professional technical summarization engine for client invoicing. Your task is to analyze detailed engineering reports (mechanical, electrical, or hydraulic) and extract the Symptoms, Cause, and Solution.

    You MUST format the output into exactly three separate paragraphs, each preceded by a bold heading and ending with a period. Use the following structure precisely, with two newline characters (\\n\\n) between each section:

    **Symptoms**
    [A professional, concise summary of the symptom(s).]

    **Cause**
    [A professional, concise summary of the cause identified.]

    **Solution**
    [A professional, concise summary of the remedy applied.]

    The total generated text, including the bold headers, paragraphs, and all newlines/spaces, MUST NOT exceed 470 characters in length. This is a strict, hard limit. Prioritize extreme brevity while maintaining professionalism.`;

  // Compute fixed overhead for headers & spacing to guide compression (we DO NOT alter your systemPrompt).
  // Headers + required newlines between sections ‚âà 40 chars:
  //   "**Symptoms**\n" (13) + "**Cause**\n" (10) + "**Solution**\n" (13) + two blank lines after first two sections (4) = 40
  const FIXED_OVERHEAD = 40;
  const TOTAL_LIMIT = 470;
  const PER_SECTION_LIMIT = Math.floor((TOTAL_LIMIT - FIXED_OVERHEAD) / 3); // ‚âà 143

  // We inline a short "constraints reminder" as extra context (not modifying your system prompt).
  function makeCombinedUserText(userText, tighten = false) {
    const reminder = tighten
      ? `\n\n[Constraints Reminder]\nTotal ‚â§ ${TOTAL_LIMIT} chars. Keep each paragraph ‚â§ ${Math.max(120, PER_SECTION_LIMIT - 10)} chars. Use aggressive compression.\n\n`
      : `\n\n[Constraints Reminder]\nTotal ‚â§ ${TOTAL_LIMIT} chars. Keep each paragraph ‚â§ ${PER_SECTION_LIMIT} chars. Be extremely concise.\n\n`;
    return `${systemPrompt}${reminder}[Engineer Notes]\n${userText}`;
  }

  // Build payload WITHOUT systemInstruction (inline prompt)
  function buildPayload(userText, tighten = false) {
    const combined = makeCombinedUserText(userText, tighten);
    return {
      contents: [{ role: "user", parts: [{ text: combined }] }],
      generationConfig: {
        temperature: 0.15,
        // Give the model ample token budget so it never truncates due to tokens.
        maxOutputTokens: 1024
      }
    };
  }

  // Likely-valid key check
  function ensureKey() {
    if (typeof USER_API_KEY !== "string" || USER_API_KEY.trim().length < 30) {
      showMessage("Error: API Key is missing or too short. Paste a valid browser key in USER_API_KEY.");
      return false;
    }
    return true;
  }

  // Call Gemini
  async function callGemini(payload) {
    const url = `${API_URL}?key=${USER_API_KEY}`;
    const response = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    if (response.status === 401) {
      throw new Error("API Key Invalid. Please check the key and referrer restrictions.");
    }
    if (!response.ok) {
      const errorBody = await response.json().catch(() => ({ error: { message: 'Non-JSON error response.' } }));
      throw new Error(`API Request failed with status ${response.status}: ${errorBody.error?.message || 'Unknown API error'}`);
    }
    return await response.json();
  }

  // Validators for your required structure
  function hasAllSections(text) {
    // Bold headers on their own lines
    const symptomsHdr  = /(^|\n)\s*\*\*Symptoms\*\*\s*$/im;
    const causeHdr     = /(^|\n)\s*\*\*Cause\*\*\s*$/im;
    const solutionHdr  = /(^|\n)\s*\*\*Solution\*\*\s*$/im;
    return symptomsHdr.test(text) && causeHdr.test(text) && solutionHdr.test(text);
  }

  function sectionsLookComplete(text) {
    // Must have three paragraphs after headers, each ending with a period.
    // We do a basic check for header, then some text, ending with period, then \n\n between sections.
    const pattern =
      /^\*\*Symptoms\*\*\s*\n[\s\S]*?\.\s*\n\n\*\*Cause\*\*\s*\n[\s\S]*?\.\s*\n\n\*\*Solution\*\*\s*\n[\s\S]*?\.\s*$/m;
    return pattern.test(text);
  }

  // Enforce total char limit with a neat trim
  function enforceLimit(text) {
    if (text.length <= TOTAL_LIMIT) return text;
    // Prefer ending at section boundary or a period under 470.
    const cutAt = Math.max(text.lastIndexOf('\n\n', TOTAL_LIMIT), text.lastIndexOf('.', TOTAL_LIMIT));
    return text.slice(0, cutAt > 0 ? cutAt + (text[cutAt] === '.' ? 1 : 0) : TOTAL_LIMIT);
  }

  async function generateSummary() {
    hideMessage();
    const userQuery = engineerInput.value.trim();

    if (!ensureKey()) return;
    if (!userQuery || /^paste engineers text here$/i.test(userQuery)) {
      showMessage("Please paste the engineer's technical notes into the input box before generating the summary.");
      return;
    }

    // UI state
    generateButton.disabled = true;
    buttonText.classList.add('hidden');
    loadingSpinner.classList.remove('hidden');
    summaryOutput.value = "Generating summary...";
    updateCharCount();

    try {
      // First attempt (normal reminder)
      let payload = buildPayload(userQuery, /* tighten */ false);
      let result  = await callGemini(payload);
      let text    = result?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";

      // Enforce limit and check structure
      text = enforceLimit(text);

      if (!sectionsLookComplete(text)) {
        // Retry once with a tighter reminder (keeps your exact structure but pushes more compression)
        payload = buildPayload(userQuery, /* tighten */ true);
        result  = await callGemini(payload);
        let retryText = result?.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || "";
        retryText = enforceLimit(retryText);

        // If retry looks complete, prefer it
        if (sectionsLookComplete(retryText)) {
          summaryOutput.value = retryText;
        } else {
          // If still not complete, at least show the best we have under the limit
          summaryOutput.value = text || "Error: Model returned an empty response.";
        }
      } else {
        summaryOutput.value = text;
      }
    } catch (error) {
      console.error("Summary Generation Error:", error);
      const displayMessage = error.message.includes("API Key Invalid")
        ? error.message
        : `Failed to generate summary. Please check your network connection and API key. Details: ${error.message}`;
      showMessage(displayMessage);
      summaryOutput.value = "Error generating summary.";
    } finally {
      // UI state: Finished
      generateButton.disabled = false;
      buttonText.classList.remove('hidden');
      loadingSpinner.classList.add('hidden');
      updateCharCount();
    }
  }

  // Copy helper
  function copyToClipboard() {
    const textToCopy = summaryOutput.value;
    if (textToCopy && textToCopy !== "Generating summary..." && textToCopy !== "Error generating summary.") {
      try {
        if (navigator.clipboard?.writeText) {
          navigator.clipboard.writeText(textToCopy).then(() => {
            copyMessage.classList.remove('opacity-0');
            setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
          });
        } else {
          summaryOutput.select();
          document.execCommand('copy');
          copyMessage.classList.remove('opacity-0');
          setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
        }
      } catch (err) {
        console.error('Could not copy text: ', err);
      }
    } else {
      showMessage("Nothing to copy or summary is still generating/in error state.");
    }
  }

  // Expose for onclick
  window.generateSummary = generateSummary;
  window.copyToClipboard = copyToClipboard;
</script>
